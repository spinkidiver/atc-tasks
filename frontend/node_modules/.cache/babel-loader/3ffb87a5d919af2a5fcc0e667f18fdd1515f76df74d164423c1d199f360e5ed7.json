{"ast":null,"code":"import { TaskRepositoryImpl } from \"@/app/task/infrastructure/repositories/TaskRepositoryImpl\";\nimport { StoreTaskUseCase, UpdateTaskUseCase } from \"@/app/task/usecases\";\nimport { TaskResponse } from \"@/app/task/interfaces/dtos/TaskResponse\";\nimport Task from \"@/app/task/domain/entities/Task\";\nimport * as yup from \"yup\";\nexport default {\n  name: \"TaskForm\",\n  props: {\n    initialData: {\n      type: Object,\n      default: () => ({\n        name: \"\",\n        description: null,\n        status: \"low\",\n        completed: false,\n        expires_at: null\n      })\n    }\n  },\n  data() {\n    return {\n      formData: {\n        ...this.initialData\n      }\n    };\n  },\n  watch: {\n    // Si cambia initialData (por ejemplo al editar), actualiza formData\n    initialData: {\n      deep: true,\n      handler(newVal) {\n        this.formData = {\n          ...newVal\n        };\n      }\n    }\n  },\n  methods: {\n    async onSubmit(values) {\n      const taskSchema = yup.object().shape({\n        id: yup.number().nullable(),\n        description: yup.string().required(),\n        active: yup.boolean().default(false)\n      });\n      const taskRepository = new TaskRepositoryImpl();\n      const taskData = new Task({\n        id: this.formData.id,\n        description: values.description,\n        active: values.active\n      });\n\n      // Attempts to coerce values to the correct type\n      let parsedData = taskSchema.cast(taskData, {\n        stripUnknown: true,\n        assert: true\n      });\n      try {\n        let taskResponse = null;\n        if (this.formData.id) {\n          // Editar categoría existente\n          const updateTaskUseCase = new UpdateTaskUseCase(taskRepository);\n          taskResponse = await updateTaskUseCase.execute(parsedData);\n          this.$emit(\"taskUpdated\");\n        } else {\n          // Agregar nueva categoría\n          const storeTaskUseCase = new StoreTaskUseCase(taskRepository);\n          taskResponse = await storeTaskUseCase.execute(parsedData);\n          this.$emit(\"taskAdded\");\n        }\n        if (!taskResponse?.error) {\n          // closeModal();\n        }\n      } catch (error) {\n        console.error(\"Error al guardar la task\", error);\n      }\n    }\n  }\n};","map":{"version":3,"names":["TaskRepositoryImpl","StoreTaskUseCase","UpdateTaskUseCase","TaskResponse","Task","yup","name","props","initialData","type","Object","default","description","status","completed","expires_at","data","formData","watch","deep","handler","newVal","methods","onSubmit","values","taskSchema","object","shape","id","number","nullable","string","required","active","boolean","taskRepository","taskData","parsedData","cast","stripUnknown","assert","taskResponse","updateTaskUseCase","execute","$emit","storeTaskUseCase","error","console"],"sources":["src/app/task/interfaces/presentation/components/TaskForm.vue"],"sourcesContent":["<!-- components/TaskForm.vue -->\n<template>\n  <form @submit.prevent=\"$emit('submit', formData)\">\n    <!-- Nombre -->\n    <b-form-group label=\"Nombre:\" label-for=\"name-input\">\n      <b-form-input\n        id=\"name-input\"\n        v-model=\"formData.name\"\n        required\n      ></b-form-input>\n    </b-form-group>\n\n    <!-- Descripción -->\n    <b-form-group label=\"Descripción:\" label-for=\"description-textarea\">\n      <b-form-textarea\n        id=\"description-textarea\"\n        v-model=\"formData.description\"\n        rows=\"3\"\n      ></b-form-textarea>\n    </b-form-group>\n\n    <!-- Estado -->\n    <b-form-group label=\"Estado:\" label-for=\"status-select\">\n      <b-form-select\n        id=\"status-select\"\n        v-model=\"formData.status\"\n        :options=\"['low', 'medium', 'high']\"\n        required\n      ></b-form-select>\n    </b-form-group>\n\n    <!-- Completado -->\n    <b-form-group label=\"¿Completada?\" label-cols-sm=\"4\" label-align-sm=\"right\">\n      <b-form-checkbox\n        v-model=\"formData.completed\"\n        switch\n        size=\"lg\"\n      ></b-form-checkbox>\n    </b-form-group>\n\n    <!-- Fecha de expiración -->\n    <b-form-group label=\"Fecha de Expiración:\" label-for=\"expires-at-input\">\n      <b-form-input\n        id=\"expires-at-input\"\n        type=\"datetime-local\"\n        v-model=\"formData.expires_at\"\n      ></b-form-input>\n    </b-form-group>\n  </form>\n</template>\n\n<script>\nimport { TaskRepositoryImpl } from \"@/app/task/infrastructure/repositories/TaskRepositoryImpl\";\nimport { StoreTaskUseCase, UpdateTaskUseCase } from \"@/app/task/usecases\";\nimport { TaskResponse } from \"@/app/task/interfaces/dtos/TaskResponse\";\nimport Task from \"@/app/task/domain/entities/Task\";\nimport * as yup from \"yup\";\n\nexport default {\n  name: \"TaskForm\",\n\n  props: {\n    initialData: {\n      type: Object,\n      default: () => ({\n        name: \"\",\n        description: null,\n        status: \"low\",\n        completed: false,\n        expires_at: null,\n      }),\n    },\n  },\n  data() {\n    return {\n      formData: { ...this.initialData },\n    };\n  },\n  watch: {\n    // Si cambia initialData (por ejemplo al editar), actualiza formData\n    initialData: {\n      deep: true,\n      handler(newVal) {\n        this.formData = { ...newVal };\n      },\n    },\n  },\n  methods: {\n    async onSubmit(values) {\n      const taskSchema = yup.object().shape({\n        id: yup.number().nullable(),\n        description: yup.string().required(),\n        active: yup.boolean().default(false),\n      });\n      const taskRepository = new TaskRepositoryImpl();\n\n      const taskData = new Task({\n        id: this.formData.id,\n        description: values.description,\n        active: values.active,\n      });\n\n      // Attempts to coerce values to the correct type\n      let parsedData = taskSchema.cast(taskData, {\n        stripUnknown: true,\n        assert: true,\n      });\n\n      try {\n        let taskResponse = null;\n\n        if (this.formData.id) {\n          // Editar categoría existente\n          const updateTaskUseCase = new UpdateTaskUseCase(taskRepository);\n          taskResponse = await updateTaskUseCase.execute(parsedData);\n          this.$emit(\"taskUpdated\");\n        } else {\n          // Agregar nueva categoría\n          const storeTaskUseCase = new StoreTaskUseCase(taskRepository);\n          taskResponse = await storeTaskUseCase.execute(parsedData);\n          this.$emit(\"taskAdded\");\n        }\n\n        if (!taskResponse?.error) {\n          // closeModal();\n        }\n      } catch (error) {\n        console.error(\"Error al guardar la task\", error);\n      }\n    },\n  },\n};\n</script>\n"],"mappings":"AAoDA,SAAAA,kBAAA;AACA,SAAAC,gBAAA,EAAAC,iBAAA;AACA,SAAAC,YAAA;AACA,OAAAC,IAAA;AACA,YAAAC,GAAA;AAEA;EACAC,IAAA;EAEAC,KAAA;IACAC,WAAA;MACAC,IAAA,EAAAC,MAAA;MACAC,OAAA,EAAAA,CAAA;QACAL,IAAA;QACAM,WAAA;QACAC,MAAA;QACAC,SAAA;QACAC,UAAA;MACA;IACA;EACA;EACAC,KAAA;IACA;MACAC,QAAA;QAAA,QAAAT;MAAA;IACA;EACA;EACAU,KAAA;IACA;IACAV,WAAA;MACAW,IAAA;MACAC,QAAAC,MAAA;QACA,KAAAJ,QAAA;UAAA,GAAAI;QAAA;MACA;IACA;EACA;EACAC,OAAA;IACA,MAAAC,SAAAC,MAAA;MACA,MAAAC,UAAA,GAAApB,GAAA,CAAAqB,MAAA,GAAAC,KAAA;QACAC,EAAA,EAAAvB,GAAA,CAAAwB,MAAA,GAAAC,QAAA;QACAlB,WAAA,EAAAP,GAAA,CAAA0B,MAAA,GAAAC,QAAA;QACAC,MAAA,EAAA5B,GAAA,CAAA6B,OAAA,GAAAvB,OAAA;MACA;MACA,MAAAwB,cAAA,OAAAnC,kBAAA;MAEA,MAAAoC,QAAA,OAAAhC,IAAA;QACAwB,EAAA,OAAAX,QAAA,CAAAW,EAAA;QACAhB,WAAA,EAAAY,MAAA,CAAAZ,WAAA;QACAqB,MAAA,EAAAT,MAAA,CAAAS;MACA;;MAEA;MACA,IAAAI,UAAA,GAAAZ,UAAA,CAAAa,IAAA,CAAAF,QAAA;QACAG,YAAA;QACAC,MAAA;MACA;MAEA;QACA,IAAAC,YAAA;QAEA,SAAAxB,QAAA,CAAAW,EAAA;UACA;UACA,MAAAc,iBAAA,OAAAxC,iBAAA,CAAAiC,cAAA;UACAM,YAAA,SAAAC,iBAAA,CAAAC,OAAA,CAAAN,UAAA;UACA,KAAAO,KAAA;QACA;UACA;UACA,MAAAC,gBAAA,OAAA5C,gBAAA,CAAAkC,cAAA;UACAM,YAAA,SAAAI,gBAAA,CAAAF,OAAA,CAAAN,UAAA;UACA,KAAAO,KAAA;QACA;QAEA,KAAAH,YAAA,EAAAK,KAAA;UACA;QAAA;MAEA,SAAAA,KAAA;QACAC,OAAA,CAAAD,KAAA,6BAAAA,KAAA;MACA;IACA;EACA;AACA","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}